---
title: "[OS] 시스템 콜"
date: "2024-03-21T09:25:03.284Z"
description: "시스템 콜의 개념과 시스템 콜의 동작 방식에 대해 알아보자."
section: "지식 공유" 
category: "CS"
tags:
  - 운영체제
thumbnailImg: "./systemcall.png"
---


## Dual Mode
### Dual Mode의 도입 배경
운영체제(OS)의 커널에서는 컴퓨터의 중요한 자원을 관리하고 있는데, 사용자가 해당 자원에 쉽게 접근하지 못하도록 보호하기 위해 OS는 작업 모드를 User Mode(유저 모드), Kernel Mode(커널 모드) 2가지로 나누었다. 이를 Dual Mode Operation이라고 한다.

OS는 시스템에 중요한 영향을 미칠 수 있는 명령어(Privileged Instruction)는 커널 모드에서만 실행할 수 있게 함으로써 하드웨어 보안을 유지한다.
<aside>

**Privileged Instruction의 예시**

- 하드웨어에 접근하기
- 다른 프로세스의 메모리에 접근하기
- 다른 프로세스를 종료시키기

</aside>

###  유저 모드와 커널 모드
*프로세스가 실행되는 동안 OS는 유저 모드와 커널 모드를 반복적으로 넘나든다.
- **User Mode(유저 모드)**

	유저(사용자, 프로세스)가 접근할 수 있는 영역을 제한적으로 두어 프로그램의 자원에 함부로 침범하지 못하는 모드.
	- 하드웨어에 직접 접근할 수 없다.
	- 사용자 애플리케이션의 코드는 유저 모드에서 실행된다.
- **Kernel Mode(커널 모드)**

	모든 시스템 자원에 접근하고 명령을 내릴 수 있는 모드.
	- 모든 시스템 메모리, 하드웨어에 직접 접근할 수 있으며 모든 CPU 명령을 실행할 수 있다.
	- 운영체제 코드나 디바이스 드라이버같은 커널모드 코드는 커널 모드에서 실행된다.

이러한 이유로 **일반적으로 사용자 프로세스는 시스템 자원에 직접 접근할 수 없다**.
## System Call
그럼 사용자 프로그램이 시스템 자원을 활용한 연산을 하려면 어떻게 해야 할까?
사용자 프로그램은 OS가 제공하는 인터페이스를 통해서만 시스템 자원을 사용할 수 있는데, 이 때 OS가 제공하는 인터페이스를 '**시스템 콜(system call)**'이라고 한다.

이를 다르게 표현해보자면 사용자 프로세스는 시스템 콜 호출을 통해 메모리에 프로그램 적재, I/O 처리, 파일시스템 처리와 같은 시스템 서비스를 제공받을 수 있다.

보통은 직접적으로 시스템 콜을 사용하기보단 API(라이브러리 함수)를 통해 사용하게 된다.
### System Call Number(시스템 콜 번호)
각 시스템 콜에 할당되는 번호. 사용자 코드는 호출하고자 하는 시스템 콜 번호를 레지스터에 저장한다.
### System Call의 구현 방식?
시스템 콜은 **시스템 콜 인터페이스**를 통해 구현된다.
- 일반적으로 시스템 콜 번호는 각 시스템 콜과 대응된다.
	- 시스템 콜 인터페이스는 이 시스템 콜 번호에 따라 인덱싱된 테이블을 두고 있음
- 시스템 콜 인터페이스는 OS 커널에서 호출된 시스템 콜을 호출하고, 시스템 콜의 상태 및 모든 반환 값을 반환한다.
- 시스템 콜을 호출한 유저 프로세스는 시스템 콜이 구현되는 방식에 대해 알 필요가 없다. 그저 API를 준수하고 OS가 시스템 콜을 호출함으로서 수행될 작업을 이해하기만 하면 된다. 
![](https://i.imgur.com/8UtqHqu.png)
요약: 응용 프로그램이 시스템 콜 번호를 가지고 시스템 콜을 호출하면, OS는 시스템 콜 테이블에서 시스템 콜 번호를 찾고, 해당 시스템 콜을 구현한 코드의 첫 부분의 주소를 찾아 실행한다.

## System Call과 함수의 차이
함수 호출은 **프로세스 스택**에 argument, return address, local variable들을 저장하고 해당 함수의 주소로 jump한다.
즉, 함수 호출 과정에서는 자신의 Context 상태를 유지한 채로 로직을 실행시킨다.

반면 시스템 콜은 **프로세스의 커널 스택**에 PC, flags, 다른 몇 개 레지스터 값을 저장하고 **Trap**을 발생시킨다. 이로 인해 유저 모드에서 **커널모드로 변경**되고, Trap 테이블을 참조하여 Trap Handler(커널 코드)로 jump한다. 이 Trap Handler는 시스템 콜과 관련된 동작을 수행할 것인데, 매개변수로 전달받은 시스템 콜 번호를 통해 시스템 콜 테이블에서 해당하는 시스템 콜 핸들러를 찾아 실행시킨다.

즉 시스템 콜 호출 과정에서는 모드의 전환이 이루어진다.
## Trap Instruction
소프트웨어에서 발생하는 Interrupt(인터럽트).
**특정 기능을 실행**하거나 사용자 프로세스에서 **예외가 발생**한 경우 트리거되는 인터럽트이다.

**트랩은 OS의 모드를 커널 모드(Kernel mode)로 변경한다.**

OS가 트랩을 감지하면 실행중이던 사용자 프로세스를 일시중지하고, OS의 모드가 커널 코드로 변경된다. System Call이 완료되면 OS 모드는 사용자 모드로 변경되고 사용자 프로세스의 실행을 재개한다.

- Trap table: 트랩 유형 별 트랩을 처리하기 위한 Trap Handler 주소가 매핑된 테이블
- Trap handler: 트랩이 발생했을 때 실행해야 하는 코드
![](https://i.imgur.com/tcsYA9P.png)

## 시스템 콜 Argument들을 OS(커널)로 전달하는 방법
1. Register들을 통해 전달하기
	Register는 CPU가 잠깐동안 기억할 수 있는 수(number) 공간이다. 
	하지만 간혹 레지스터 용량보다 많은 파라미터가 필요한 경우가 있다.
2. Arguments를 메모리 내 block으로 저장하고, 해당 block 주소를 register를 통해 전달한다.
	리눅스와 솔라리스 OS에서 사용하고 있는 방법
3. Arguments를 스택에 push하고 kernel이 직접 pop하는 방식
	파라미터의 크기나 개수에 제약이 없는 방법.
![](https://i.imgur.com/RWnEssP.png)


## System Call의 종류
시스템 콜에는 크게 6가지 종류가 있다.
### Process control(프로세스 제어)
- 프로세스 생성&종료/중단
- 프로세스 로드, 실행
- 프로세스 정보 조회 및 설정
- 대기 이벤트, 시그널 이벤트
- 메모리 할당 및 사용 가능
### File Management(파일 관리)
- 파일 관리
- 파일 만들기, 파일 삭제
- 읽기, 쓰기, 재배치
- 파일 속성 가져오기 및 설정
### Device Management(디바이스(I/O 장치) 관리)
- 읽기, 쓰기, 재배치
- 장치 정보 가져오기 및 설정
- 논리적으로 장치 연결 및 분리
### Information Maintenance
- 시간/날짜 설정
- 시스템 데이터 조회 및 설정
- 프로세스, 파일, I/O 장치 정보 조회 및 설정
### Communizations(소켓 통신)
- 통신 연결 생성 & 삭제
- 원격 장치 연결 및 분리
### Protections(보안)
- 리소스에 대한 접근 제어
- 권한 조회 및 설정
- 사용자 접근 허용 & 거부